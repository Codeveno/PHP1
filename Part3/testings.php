//we are mostly going to write tests  in this esctions

//we are going to use the phpunit framework
//tests in phpunit are written in classes
//below is example list of tests in php_unit    
//1. Unit tests: These tests focus on individual units of code, such as functions or methods, to ensure they work as expected.
//2. Integration tests: These tests check how different components of the application work together.
//3. Functional tests: These tests evaluate the application's functionality from the user's perspective, simulating real-world scenarios.
//4. Acceptance tests: These tests verify that the application meets business requirements and is ready for deployment.
//5. Regression tests: These tests ensure that new changes or features do not break existing functionality.
//6. Performance tests: These tests assess the application's performance under various conditions, such as load and stress testing.
//7. Security tests: These tests identify vulnerabilities and ensure that the application is secure against potential threats.
//8. Smoke tests: These tests provide a quick check to ensure that the most critical functions of the application work after a new build or deployment.
//9. End-to-end tests: These tests validate the entire application flow, from the user interface to the backend, ensuring that all components work together seamlessly.
//10. API tests: These tests verify the functionality and performance of application programming interfaces (APIs) to ensure they meet specifications and handle requests correctly.
//11. Database tests: These tests check the integrity and performance of the database, ensuring that data is stored and retrieved correctly.
//12. Cross-browser tests: These tests ensure that the application works correctly across different web browsers and devices.
//13. Usability tests: These tests evaluate the user experience and interface design to ensure that the application is user-friendly and intuitive.
//14. Localization tests: These tests verify that the application works correctly in different languages and regions, ensuring proper formatting and translations.
//15. Compatibility tests: These tests ensure that the application works correctly with different operating systems, browsers, and devices.
//16. Load tests: These tests assess how the application performs under heavy load, simulating multiple users or transactions.
//17. Stress tests: These tests evaluate the application's behavior under extreme conditions, such as high traffic or resource limitations.
//18. Scalability tests: These tests assess the application's ability to scale up or down based on demand, ensuring it can handle increased workloads.
//19. Recovery tests: These tests verify the application's ability to recover from failures, such as crashes or data loss.
//20. Continuous integration tests: These tests are automatically run as part of the continuous integration process, ensuring that code changes do not introduce new issues.
//21. Continuous deployment tests: These tests are automatically run as part of the continuous deployment process, ensuring that code changes can be safely deployed to production.
//22. Code quality tests: These tests assess the quality of the codebase, checking for issues such as code style, complexity, and maintainability.
//23. Code coverage tests: These tests measure the percentage of code that is executed during testing, helping to identify untested areas of the codebase.
//24. Static analysis tests: These tests analyze the code without executing it, identifying potential issues such as security vulnerabilities or performance bottlenecks.
//25. Dynamic analysis tests: These tests analyze the code while it is running, identifying issues such as memory leaks or performance problems.
//26. Mutation tests: These tests evaluate the effectiveness of the test suite by introducing small changes (mutations) to the code and checking if the tests can detect them.
//27. Fuzz tests: These tests provide random or unexpected input to the application to identify potential vulnerabilities or crashes.
//28. Exploratory tests: These tests involve manual testing of the application to discover issues that may not be covered by automated tests.
//29. Pairwise tests: These tests evaluate the application by testing all possible pairs of input values, ensuring that combinations of inputs are covered.
//30. Boundary tests: These tests check the application's behavior at the edges of input ranges, ensuring that it handles extreme values correctly.
//31. Data-driven tests: These tests use external data sources (e.g., CSV files, databases) to run the same test with different input values, ensuring comprehensive coverage.
//32. Behavior-driven tests: These tests focus on the expected behavior of the application, often using natural language to describe scenarios and outcomes.
//33. Test-driven development (TDD): This approach involves writing tests before writing the actual code, ensuring that the code meets the specified requirements from the start.
//34. Behavior-driven development (BDD): This approach focuses on the behavior of the application from the user's perspective, often using natural language to describe scenarios and outcomes.
//35. Risk-based testing: This approach prioritizes testing based on the potential risks and impact of failures, ensuring that critical areas are thoroughly tested.

